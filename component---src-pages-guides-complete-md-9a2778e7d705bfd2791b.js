(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{161:function(e,n,t){"use strict";t.r(n),t.d(n,"_frontmatter",function(){return c});var a=t(176),o=t.n(a),r=t(0),i=t.n(r),s=t(172),m=t(171);n.default=function(e){var n=e.components,t=o()(e,["components"]);return i.a.createElement(s.MDXTag,{name:"wrapper",Layout:m.a,layoutProps:t,components:n},i.a.createElement(s.MDXTag,{name:"h1",components:n,props:{id:"complete-guide"}},i.a.createElement(s.MDXTag,{name:"a",components:n,parentName:"h1",props:{href:"#complete-guide","aria-hidden":!0,class:"anchor"}}),"Complete Guide"),i.a.createElement(s.MDXTag,{name:"p",components:n},"This is a guide that takes you through all the important parts of ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"xstate")," and statecharts by building a sample app."),i.a.createElement(s.MDXTag,{name:"p",components:n},"Let's say we're developing an app that retrieves Star Wars data from ",i.a.createElement(s.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://swapi.co"}},"The Star Wars API"),". To accomplish this, we'll be dealing with asynchronous API requests in the form of promises."),i.a.createElement(s.MDXTag,{name:"p",components:n},"A promise is ",i.a.createElement(s.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://www.promisejs.org/implementing/"}},"just a state machine")," with 3 states:"),i.a.createElement(s.MDXTag,{name:"ul",components:n},i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"'pending'")," - the Promise has not yet been resolved or rejected"),i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"'fulfilled'")," - the Promise has succeeded and has been resolved"),i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"'rejected'")," - the Promise has failed and has been rejected")),i.a.createElement(s.MDXTag,{name:"p",components:n},"When starting the app, no promises have been made yet. We can represent this with the initial ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'idle'")," state. Let's go ahead and use ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"xstate")," to model this state machine."),i.a.createElement(s.MDXTag,{name:"h2",components:n,props:{id:"installation"}},i.a.createElement(s.MDXTag,{name:"a",components:n,parentName:"h2",props:{href:"#installation","aria-hidden":!0,class:"anchor"}}),"Installation"),i.a.createElement(s.MDXTag,{name:"p",components:n},"First, install ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"xstate")," into your project (more details in ",i.a.createElement(s.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"README#installation"}},"the readme"),"):"),i.a.createElement(s.MDXTag,{name:"pre",components:n},i.a.createElement(s.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-bash",metaString:""}},"npm install xstate --save\n")),i.a.createElement(s.MDXTag,{name:"p",components:n},"Then, import the ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"Machine")," function into your application code:"),i.a.createElement(s.MDXTag,{name:"pre",components:n},i.a.createElement(s.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"// index.js\nimport { Machine } from 'xstate';\n")),i.a.createElement(s.MDXTag,{name:"h2",components:n,props:{id:"creating-the-finite-state-machine"}},i.a.createElement(s.MDXTag,{name:"a",components:n,parentName:"h2",props:{href:"#creating-the-finite-state-machine","aria-hidden":!0,class:"anchor"}}),"Creating the Finite State Machine"),i.a.createElement(s.MDXTag,{name:"p",components:n},"A simple finite state machine in ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"xstate")," is configured with two properties:"),i.a.createElement(s.MDXTag,{name:"ul",components:n},i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"initial")," - the initial state (in this case, ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"'idle'"),")"),i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"states")," - an object mapping ",i.a.createElement(s.MDXTag,{name:"strong",components:n,parentName:"li"},"state keys")," to their state configuration.")),i.a.createElement(s.MDXTag,{name:"p",components:n},"To start, the states will be configured with an ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"on")," property, which is an object mapping ",i.a.createElement(s.MDXTag,{name:"strong",components:n,parentName:"p"},"events")," to their ",i.a.createElement(s.MDXTag,{name:"strong",components:n,parentName:"p"},"next state keys"),":"),i.a.createElement(s.MDXTag,{name:"p",components:n},i.a.createElement(s.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://i.imgur.com/4qXh3Jx.png",alt:"Star Wars Promise State Machine"}})),i.a.createElement(s.MDXTag,{name:"pre",components:n},i.a.createElement(s.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"const starWarsMachine = Machine({\n  // start in the 'idle' state\n  initial: 'idle',\n  states: {\n    idle: {\n      on: {\n        // when a 'REQUEST' event occurs in the 'idle' state,\n        // transition to the 'pending' state\n        REQUEST: 'pending'\n      }\n    },\n    pending: {\n      on: {\n        // when a 'pending' promise receives a 'SUCCESS' event,\n        // transition to the 'fulfilled' state\n        SUCCESS: 'fulfilled',\n        // however, when a 'pending' promise receives a 'FAILURE' event,\n        // transition to the 'rejected' state instead\n        FAILURE: 'rejected'\n      }\n    },\n    fulfilled: {\n      on: {\n        // our machine can allow a request to be made multiple times,\n        // so allow a transition back to 'pending' upon a 'REQUEST' event.\n        REQUEST: 'pending'\n      }\n    },\n    rejected: {\n      on: {\n        // similarly, in case of failure, allow the user to try again.\n        REQUEST: 'pending'\n      }\n    }\n  }\n});\n")),i.a.createElement(s.MDXTag,{name:"h2",components:n,props:{id:"transitions"}},i.a.createElement(s.MDXTag,{name:"a",components:n,parentName:"h2",props:{href:"#transitions","aria-hidden":!0,class:"anchor"}}),"Transitions"),i.a.createElement(s.MDXTag,{name:"p",components:n},'The main purpose of this machine is to allow you, the developer, to answer the question "When the app is in a certain state, and an event occurs, what will the next state be?" To do this with ',i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"xstate"),", we'll use the ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},".transition")," method which takes two arguments:"),i.a.createElement(s.MDXTag,{name:"ul",components:n},i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"stateValue")," - the state we want to transition from (we'll use string keys for now)"),i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"event")," - the event that occurred (we'll use a string event name for now)")),i.a.createElement(s.MDXTag,{name:"pre",components:n},i.a.createElement(s.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"console.log(starWarsMachine\n  .transition('idle', 'REQUEST')\n  .value);\n// => 'pending'\n\nconsole.log(starWarsMachine\n  .transition('pending', 'SUCCESS')\n  .value);\n// => 'fulfilled'\n\nconsole.log(starWarsMachine\n  .transition('pending', 'REQUEST')\n  .value);\n// => 'pending'\n// notice how the state does not (and should not) change!\n\nconsole.log(starWarsMachine\n  .transition('fulfilled', 'REQUEST')\n  .value);\n// => 'pending'\n")),i.a.createElement(s.MDXTag,{name:"p",components:n},"There's two things to keep in mind:"),i.a.createElement(s.MDXTag,{name:"ul",components:n},i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},"The ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},".transition(...)")," function is a ",i.a.createElement(s.MDXTag,{name:"em",components:n,parentName:"li"},"pure function"),", meaning it always returns the same value given the same arguments, and it never causes any side effects. We'll get to purposeful side effects (actions) later."),i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},"We need to extract the value from the result using ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},".value"),". This is because ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},".transition(...)")," actually returns a ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"State")," instance, which looks like this:")),i.a.createElement(s.MDXTag,{name:"pre",components:n},i.a.createElement(s.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"starWarsMachine.transition('idle', 'REQUEST');\n\n// State {\n//   value: 'pending',\n//   history: undefined,\n//   actions: []\n// }\n")),i.a.createElement(s.MDXTag,{name:"h2",components:n,props:{id:"actions"}},i.a.createElement(s.MDXTag,{name:"a",components:n,parentName:"h2",props:{href:"#actions","aria-hidden":!0,class:"anchor"}}),"Actions"),i.a.createElement(s.MDXTag,{name:"p",components:n},"Pure functions are nice, but apps have to have side-effects in order to actually do anything. In ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"xstate")," (and in the statechart specification) an ",i.a.createElement(s.MDXTag,{name:"strong",components:n,parentName:"p"},"action")," is a side-effect (or a ",i.a.createElement(s.MDXTag,{name:"em",components:n,parentName:"p"},"reaction"),") that can occur on 3 potential instances:"),i.a.createElement(s.MDXTag,{name:"ul",components:n},i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},"when a state is ",i.a.createElement(s.MDXTag,{name:"em",components:n,parentName:"li"},"entered")," (",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"onEntry"),")"),i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},"when a state is ",i.a.createElement(s.MDXTag,{name:"em",components:n,parentName:"li"},"exited")," (",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"onExit"),")"),i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},"when a transition occurs (transition ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"actions"),")")),i.a.createElement(s.MDXTag,{name:"p",components:n},"Actions are specified by strings (or arrays of strings):"),i.a.createElement(s.MDXTag,{name:"pre",components:n},i.a.createElement(s.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"const starWarsMachine = Machine({\n  // ...\n  states: {\n    idle: {\n      on: {\n        REQUEST: {\n          target: 'pending', // since 4.0\n          // the `actions` prop specifies which actions should be\n          // executed on this idle --\x3e pending transition\n          actions: ['alertStartingFirstRequest']\n        }\n      },\n      onExit: 'alertMayTheForceBeWithYou'\n    },\n    pending: {\n      on: {\n        SUCCESS: 'fulfilled',\n        FAILURE: 'rejected'\n      }\n      onEntry: 'fetchPerson',\n      onExit: 'alertRequestFinished'\n    },\n  }\n});\n\nconst nextState = starWarsMachine.transition('idle', 'REQUEST');\n\n// State {\n//   value: 'pending',\n//   history: undefined,\n//   actions: [\n//     'alertMayTheForceBeWithYou',\n//     'alertStartingFirstRequest',\n//     'fetchPerson'\n//   ]\n// }\n")),i.a.createElement(s.MDXTag,{name:"p",components:n},"The actions to be executed are an array on the ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"actions")," ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"State")," instance. The action order goes:\n1. any ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"onExit")," actions of child states\n2. any ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"onExit")," actions of parent states\n3. any ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"actions")," on transitions\n4. any ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"onEntry")," actions of parent states\n5. any ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"onEntry")," actions of child states"),i.a.createElement(s.MDXTag,{name:"p",components:n},"From here, executing actions (side-effects) in your app is completely up to you. Here's one way of doing it:"),i.a.createElement(s.MDXTag,{name:"pre",components:n},i.a.createElement(s.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"const actionMap = {\n  alertStartingFirstRequest: () => alert('Starting first request!'),\n  alertMayTheForceBeWithYou: () => alert('May the force be with you.'),\n  fetchPerson: ({ id }, dispatch) => fetch(`https://swapi.co/api/people/${id}`)\n    .then(res => res.json())\n    .then(res => dispatch({\n      type: 'SUCCESS',\n      payload: res\n    }))\n    .catch(err => dispatch({\n      type: 'FAILURE',\n      error: err\n    })),\n  alertRequestFinished: () => alert('Request finished!'),  \n};\n\n// atomic state - there are many different ways to update this\nlet currentState = starWarsMachine.initialState; // 'idle'\n\nfunction dispatch(event) {\n  const nextState = starWarsMachine\n    .transition(currentState, event);\n\n  nextState.actions.forEach(actionKey => {\n    const action = actionMap[actionKey];\n\n    if (action) {\n      // in this example, `dispatch` is passed into the action\n      // in case the action emits other events\n      action(event, dispatch);\n    }\n  });\n\n  // update the atomic state (yes, there's better ways of doing this)\n  currentState = nextState.value;\n}\n\n// this event can come from anywhere, e.g., the UI\nconst requestEvent = {\n  type: 'REQUEST',\n  id: 3\n};\n\n// similar to Redux, this can be the result of a button click, an internal action, etc.\ndispatch(requestEvent);\n")),i.a.createElement(s.MDXTag,{name:"p",components:n},"There's a couple of things happening here:"),i.a.createElement(s.MDXTag,{name:"ul",components:n},i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},"An ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"actionMap")," is defined, which maps string action keys to their actual implementation. This means you can ",i.a.createElement(s.MDXTag,{name:"em",components:n,parentName:"li"},"reuse")," the exact same statechart in other applications, frameworks, or environments, where the implementation might be different. 💥"),i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},"Each action function takes in the ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"event")," data, as well as a ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"dispatch")," (or ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"emit"),") function if the action will dispatch more events.")),i.a.createElement(s.MDXTag,{name:"p",components:n},"When an ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"event")," is dispatched:"),i.a.createElement(s.MDXTag,{name:"ul",components:n},i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},"First the ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"nextState")," will be determined."),i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},"Then, the ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"actions")," from that state will be executed in order.")),i.a.createElement(s.MDXTag,{name:"p",components:n},"And from that, you have a working app!"),i.a.createElement(s.MDXTag,{name:"h2",components:n,props:{id:"hierarchical-nested-states"}},i.a.createElement(s.MDXTag,{name:"a",components:n,parentName:"h2",props:{href:"#hierarchical-nested-states","aria-hidden":!0,class:"anchor"}}),"Hierarchical (Nested) States"),i.a.createElement(s.MDXTag,{name:"p",components:n},"Suppose we want to retrieve data from the API about:"),i.a.createElement(s.MDXTag,{name:"ul",components:n},i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},"A Star Wars person"),i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},"That person's planet.")),i.a.createElement(s.MDXTag,{name:"p",components:n},"We'll have to make two API calls, and we might want to show more detail in the UI for when:"),i.a.createElement(s.MDXTag,{name:"ul",components:n},i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},"The person is finished loading"),i.a.createElement(s.MDXTag,{name:"li",components:n,parentName:"ul"},"The person's planet is finished loading.")),i.a.createElement(s.MDXTag,{name:"p",components:n},"Hierarchical states (or nested states) can provide more granularity without making the state machine needlessly complex. Here's how we can represent our new requirements:"),i.a.createElement(s.MDXTag,{name:"p",components:n},i.a.createElement(s.MDXTag,{name:"img",components:n,parentName:"p",props:{src:"https://i.imgur.com/BHEHhNc.png",alt:"Star Wars Statechart"}})),i.a.createElement(s.MDXTag,{name:"pre",components:n},i.a.createElement(s.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"const starWarsMachine = Machine({\n  initial: 'idle',\n  states: {\n    idle: {\n      on: { REQUEST: 'pending' }\n    },\n    pending: {\n      initial: 'loadingPerson',\n      states: {\n        loadingPerson: {\n          on: {\n            SUCCESS_PERSON: 'loadingPlanet'\n          },\n          onEntry: 'fetchPerson'\n        },\n        loadingPlanet: {\n          onEntry: 'fetchPlanet'\n        }\n      },\n      on: {\n        SUCCESS_PLANET: 'fulfilled',\n        FAILURE_PERSON: 'rejected',\n        FAILURE_PLANET: 'rejected'\n      }\n    },\n    fulfilled: {\n      on: { REQUEST: 'pending' },\n      onEntry: 'logResult'\n    },\n    rejected: {\n      on: { REQUEST: 'pending' }\n    }\n  }\n});\n")),i.a.createElement(s.MDXTag,{name:"p",components:n},"Here's what will happen when a request is made now:\n1. From the initial ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'idle'")," state, a ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'REQUEST'")," event will trigger a transition to the ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'pending'")," state\n2. The ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'pending'")," state itself has two substates: the initial ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'loadingPerson'")," and ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'loadingPlanet'")," states. Entering the ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'pending'")," state is equivalent to entering its initial state, ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'pending.loadingPerson'"),".\n3. The ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"onEntry")," action of ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'pending.loadingPerson'"),", which is ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'fetchPerson'"),", will be executed (remember: ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"xstate")," does not do this, you do!)\n4. If successful, a ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'SUCCESS_PERSON'")," event will be dispatched, which will trigger a transition to the ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'pending.loadingPlanet'")," state.\n5. The ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"onEntry")," action of ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'pending.loadingPlanet'")," (",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'fetchPlanet'"),") will then be executed.\n6. If successful, a ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'SUCCESS_PLANET'")," event will be dispatched."),i.a.createElement(s.MDXTag,{name:"p",components:n},"Here, it gets interesting. You'll notice that ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'pending.loadingPlanet'")," does ",i.a.createElement(s.MDXTag,{name:"em",components:n,parentName:"p"},"not")," have a transition on the ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'SUCCESS_PLANET'")," event (or any transition, for that matter). In this case, the event will be handled by the ",i.a.createElement(s.MDXTag,{name:"strong",components:n,parentName:"p"},"parent state"),", which is ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'pending'"),". From there, ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'pending'")," will transition to the ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'fulfilled'")," state according to the config."),i.a.createElement(s.MDXTag,{name:"p",components:n},"Also, the representation of state values for nested states is now object-based:"),i.a.createElement(s.MDXTag,{name:"pre",components:n},i.a.createElement(s.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"starWarsMachine.transition('idle', { type: 'REQUEST', id: 3 });\n\n// State {\n//   value: { pending: 'loadingPerson' },\n//   history: undefined,\n//   actions: ['fetchPerson']\n// }\n")),i.a.createElement(s.MDXTag,{name:"p",components:n},"Here, ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"{ pending: 'loadingPerson' }")," represents that the app is in the ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'pending'")," state, and that the ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'pending'")," state is in the ",i.a.createElement(s.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"'loadingPerson'")," state. It's useful to represent state values in a tree structure this way, since we'll see in the future that you can be in more than one state (parallel states) at the same time, and that states can be deeply nested."),i.a.createElement(s.MDXTag,{name:"p",components:n},"So what does all this look like in code?"),i.a.createElement(s.MDXTag,{name:"pre",components:n},i.a.createElement(s.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"// revise the action map\nconst actionMap = {\n  fetchPerson: ({ id }, dispatch) => fetch(`https://swapi.co/api/people/${id}`)\n    .then(res => res.json())\n    .then(res => dispatch({\n      type: 'SUCCESS_PERSON',\n      payload: res\n    }))\n    .catch(err => dispatch({\n      type: 'FAILURE_PERSON',\n      error: err\n    })),\n  fetchPlanet: ({ payload }, dispatch) => fetch(payload.homeworld)\n    .then(res => res.json())\n    .then(res => dispatch({\n      type: 'SUCCESS_PLANET',\n      payload: res\n    }))\n    .catch(err => dispatch({\n      type: 'FAILURE_PLANET',\n      error: err\n    })),\n  logResult: ({ payload }) => console.log(payload)\n};\n\nconst id = prompt('Star Wars person ID'); // e.g., 3\n\n// ... (same currentState + dispatch code as before)\n\ndispatch({ type: 'REQUEST', id });\n// will eventually log (if successful):\n// {\n//   name: 'Naboo',\n//   climate: 'temperate',\n//   ... etc.\n// }\n")),i.a.createElement(s.MDXTag,{name:"p",components:n},"To be continued!"))};var c={}},164:function(e,n,t){"use strict";t.r(n),t.d(n,"graphql",function(){return g}),t.d(n,"StaticQueryContext",function(){return h}),t.d(n,"StaticQuery",function(){return u});var a=t(0),o=t.n(a),r=t(4),i=t.n(r),s=t(163),m=t.n(s);t.d(n,"Link",function(){return m.a}),t.d(n,"withPrefix",function(){return s.withPrefix}),t.d(n,"navigate",function(){return s.navigate}),t.d(n,"push",function(){return s.push}),t.d(n,"replace",function(){return s.replace}),t.d(n,"navigateTo",function(){return s.navigateTo});var c=t(28);t.d(n,"waitForRouteChange",function(){return c.c});var l=t(165),p=t.n(l);t.d(n,"PageRenderer",function(){return p.a});var d=t(39);t.d(n,"parsePath",function(){return d.a});var h=o.a.createContext({}),u=function(e){return o.a.createElement(h.Consumer,null,function(n){return e.data||n[e.query]&&n[e.query].data?(e.render||e.children)(e.data?e.data.data:n[e.query].data):o.a.createElement("div",null,"Loading (StaticQuery)")})};function g(){throw new Error("It appears like Gatsby is misconfigured. Gatsby related `graphql` calls are supposed to only be evaluated at compile time, and then compiled away,. Unfortunately, something went wrong and the query was left in the compiled code.\n\n.Unless your site has a complex or custom babel/Gatsby configuration this is likely a bug in Gatsby.")}u.propTypes={data:i.a.object,query:i.a.string.isRequired,render:i.a.func,children:i.a.func}},165:function(e,n,t){var a;e.exports=(a=t(168))&&a.default||a},166:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0}),n.withMDXComponents=void 0;var a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},o=s(t(0)),r=s(t(54)),i=s(t(4));function s(e){return e&&e.__esModule?e:{default:e}}var m=(0,r.default)({}),c=m.Provider,l=m.Consumer;n.withMDXComponents=function(e){return function(n){var t=n.components,r=function(e,n){var t={};for(var a in e)n.indexOf(a)>=0||Object.prototype.hasOwnProperty.call(e,a)&&(t[a]=e[a]);return t}(n,["components"]);return o.default.createElement(l,null,function(n){return o.default.createElement(e,a({components:t||n},r))})}};var p=function(e){var n=e.components,t=e.children;return o.default.createElement(c,{value:n},t)};p.propTypes={components:i.default.object.isRequired,children:i.default.element.isRequired},n.default=p},167:function(e){e.exports={data:{site:{siteMetadata:{title:"Xstate Docs"}}}}},168:function(e,n,t){"use strict";t.r(n);var a=t(11),o=t.n(a),r=t(0),i=t.n(r),s=t(4),m=t.n(s),c=t(53),l=t(1),p=function(e){var n=e.location,t=l.default.getResourcesForPathnameSync(n.pathname);return i.a.createElement(c.a,o()({location:n,pageResources:t},t.json))};p.propTypes={location:m.a.shape({pathname:m.a.string.isRequired}).isRequired},n.default=p},169:function(e,n,t){},171:function(e,n,t){"use strict";var a=t(167),o=t(0),r=t.n(o),i=t(4),s=t.n(i),m=t(175),c=t.n(m),l=t(164),p=function(e){var n=e.siteTitle;return r.a.createElement("div",{style:{background:"rebeccapurple",marginBottom:"1.45rem"}},r.a.createElement("div",{style:{margin:"0 auto",maxWidth:960,padding:"1.45rem 1.0875rem"}},r.a.createElement("h1",{style:{margin:0}},r.a.createElement(l.Link,{to:"/",style:{color:"white",textDecoration:"none"}},n))))},d=(t(169),function(e){var n=e.children;return r.a.createElement(l.StaticQuery,{query:"755544856",render:function(e){return r.a.createElement(r.a.Fragment,null,r.a.createElement(c.a,{title:e.site.siteMetadata.title,meta:[{name:"description",content:"Sample"},{name:"keywords",content:"sample, something"}]},r.a.createElement("html",{lang:"en"})),r.a.createElement(p,{siteTitle:e.site.siteMetadata.title}),r.a.createElement("div",{style:{margin:"0 auto",maxWidth:960,padding:"0px 1.0875rem 1.45rem",paddingTop:0}},n))},data:a})});d.propTypes={children:s.a.node.isRequired};n.a=d},172:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a=t(173);Object.defineProperty(n,"MDXTag",{enumerable:!0,get:function(){return r(a).default}});var o=t(166);function r(e){return e&&e.__esModule?e:{default:e}}Object.defineProperty(n,"MDXProvider",{enumerable:!0,get:function(){return r(o).default}})},173:function(e,n,t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var a=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a])}return e},o=function(){function e(e,n){for(var t=0;t<n.length;t++){var a=n[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(e,a.key,a)}}return function(n,t,a){return t&&e(n.prototype,t),a&&e(n,a),n}}(),r=t(0),i=c(r),s=c(t(174)),m=t(166);function c(e){return e&&e.__esModule?e:{default:e}}var l={inlineCode:"code",wrapper:"div"},p=function(e){function n(){return function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,n),function(e,n){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!n||"object"!=typeof n&&"function"!=typeof n?e:n}(this,(n.__proto__||Object.getPrototypeOf(n)).apply(this,arguments))}return function(e,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function, not "+typeof n);e.prototype=Object.create(n&&n.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),n&&(Object.setPrototypeOf?Object.setPrototypeOf(e,n):e.__proto__=n)}(n,r.Component),o(n,[{key:"render",value:function(){var e=this.props,n=e.name,t=e.parentName,o=e.props,r=void 0===o?{}:o,m=e.children,c=e.components,p=void 0===c?{}:c,d=e.Layout,h=e.layoutProps,u=p[t+"."+n]||p[n]||l[n]||n;return d?((0,s.default)(this,d),i.default.createElement(d,a({components:p},h),i.default.createElement(u,r,m))):i.default.createElement(u,r,m)}}]),n}();n.default=(0,m.withMDXComponents)(p)},174:function(e,n,t){"use strict";var a={childContextTypes:!0,contextTypes:!0,defaultProps:!0,displayName:!0,getDefaultProps:!0,getDerivedStateFromProps:!0,mixins:!0,propTypes:!0,type:!0},o={name:!0,length:!0,prototype:!0,caller:!0,callee:!0,arguments:!0,arity:!0},r=Object.defineProperty,i=Object.getOwnPropertyNames,s=Object.getOwnPropertySymbols,m=Object.getOwnPropertyDescriptor,c=Object.getPrototypeOf,l=c&&c(Object);e.exports=function e(n,t,p){if("string"!=typeof t){if(l){var d=c(t);d&&d!==l&&e(n,d,p)}var h=i(t);s&&(h=h.concat(s(t)));for(var u=0;u<h.length;++u){var g=h[u];if(!(a[g]||o[g]||p&&p[g])){var E=m(t,g);try{r(n,g,E)}catch(e){}}}return n}return n}}}]);
//# sourceMappingURL=component---src-pages-guides-complete-md-9a2778e7d705bfd2791b.js.map